<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PGR New Starter Roster Creation Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="A professional tool for creating new team member training rosters for PGR at The Star Gold Coast." />
  <meta name="theme-color" content="#1a1a1a" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="logo.png">
  <link rel="icon" sizes="192x192" href="https://placehold.co/192x192/png">
  <link rel="icon" sizes="512x512" href="https://placehold.co/512x512/png">

  <style>
    /* --- Signature Typeface Palette --- */
    @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&family=Playfair+Display:wght@500;600;700&display=swap');

    /* --- CSS Variables & Base Styles --- */
    :root {
      --font-sans: 'Plus Jakarta Sans', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      --font-serif: 'Playfair Display', 'Times New Roman', serif;

      --bg-primary: #0e0e0e;
      --bg-secondary: #181818;
      --bg-tertiary: #242424;
      --surface: #1e1e1e;
      --surface-alt: #131313;
      --bg-gradient: radial-gradient(circle at top left, #1c1c1c 0%, #0b0b0b 100%);

      --text-primary: #f5f5f5;
      --text-secondary: #a3a3a3;
      --text-muted: #737373;

      --border-primary: #404040;
      --border-secondary: #525252;

      --brand-primary: #B92B27; /* Deep Red */
      --brand-secondary: #D4AF37;/* Rich Gold */
      --brand-gradient: linear-gradient(90deg, var(--brand-primary) 0%, #E74C3C 100%);

      --warn-primary: #f59e0b;
      --ok-primary: #22c55e;

      --radius-sm: 0.375rem;
      --radius-md: 0.5rem;
      --radius-lg: 0.75rem;

      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -2px rgb(0 0 0 / 0.1);
    }

    *, *::before, *::after { box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body { margin: 0; font-family: var(--font-sans); font-size: 14px; line-height: 1.5; color: var(--text-primary); background: var(--bg-gradient); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    .app { display: grid; grid-template-columns: 280px 1fr; min-height: 100vh; }
    .side { position: sticky; top: 0; height: 100vh; padding: 1.5rem; background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%); border-right: 1px solid var(--border-primary); box-shadow: 2px 0 8px rgba(0,0,0,0.4); display: flex; flex-direction: column; gap: 2rem; }
    .main { padding: 2rem; display: grid; gap: 1.5rem; align-content: start; }
    .brand { display: flex; align-items: center; gap: 0.75rem; }
    .logo { width: 50px; height: 50px; border-radius: var(--radius-md); }
    .brand .product h1 { font-family: var(--font-serif); font-size: 1.25rem; font-weight: 700; margin: 0; line-height: 1.2; color: var(--brand-secondary); }
      .brand .product .subbrand { font-size: 0.75rem; color: var(--text-secondary); }
      .brand .product .tagline { font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem; }
    .nav-group { display: flex; flex-direction: column; gap: 0.5rem; }
    .nav-group h2 { font-family: var(--font-serif); font-size: 0.875rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin: 0 0 0.5rem; padding: 0 0.5rem; }
    .nav-chips { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .chip { display: inline-flex; align-items: center; padding: 0.375rem 0.75rem; border-radius: var(--radius-md); background-color: var(--bg-tertiary); border: 1px solid var(--border-primary); font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); }
    .starter-cell { display: inline-flex; align-items: center; gap: 0.5rem; }
    .starter-avatar { display: inline-flex; align-items: center; justify-content: center; width: 1.75rem; height: 1.75rem; border-radius: 999px; background-color: var(--bg-tertiary); border: 1px solid var(--border-primary); font-size: 1.2rem; }
    .group-row-header { display: flex; align-items: center; gap: 0.75rem; }
    .group-row-subtext { font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem; }
    .toolbar { position: sticky; top: 0; z-index: 10; display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; padding: 1rem; margin: -2rem -2rem 0; background: linear-gradient(180deg, rgba(16, 12, 12, 0.95) 70%, transparent 100%); backdrop-filter: blur(8px); border-bottom: 1px solid var(--border-primary); }
    #conflicts { margin-left: auto; font-size: 0.875rem; color: var(--text-secondary); background-color: var(--bg-tertiary); padding: 0.5rem 1rem; border-radius: var(--radius-md); border: 1px solid var(--border-primary); }
    .card { background: linear-gradient(180deg, var(--surface) 0%, var(--surface-alt) 100%); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); overflow: hidden; }
    .card .hd { display: flex; align-items: center; justify-content: space-between; gap: 1rem; padding: 1rem 1.5rem; border-bottom: 1px solid var(--border-primary); background-color: var(--bg-tertiary); }
    .card .hd h2 { font-family: var(--font-serif); font-size: 1rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; margin: 0; color: var(--text-secondary); }
    .card .hd .sub { font-size: 0.875rem; color: var(--text-muted); }
    .card .bd { padding: 1.5rem; }
    .grid { display: grid; gap: 1rem; }
    .g2 { grid-template-columns: repeat(2, 1fr); }
    .g3 { grid-template-columns: repeat(3, 1fr); }
    .g4 { grid-template-columns: repeat(4, 1fr); }
    label { display: block; font-size: 0.75rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem; }
    input, textarea, select { width: 100%; font-family: inherit; font-size: 0.875rem; color: var(--text-primary); background-color: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 0.625rem 0.75rem; transition: border-color 0.2s, box-shadow 0.2s; }
    input:focus, textarea:focus, select:focus { outline: none; border-color: var(--brand-primary); box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--brand-primary); }
    textarea { min-height: 160px; resize: vertical; }
    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; font-family: inherit; font-size: 0.875rem; font-weight: 600; padding: 0.625rem 1rem; border-radius: var(--radius-md); border: 1px solid var(--border-secondary); background-color: var(--bg-tertiary); color: var(--text-primary); cursor: pointer; transition: all 0.15s ease-in-out; user-select: none; }
    .btn:hover { background-color: #374151; border-color: #4b5563; }
    .btn:active { transform: scale(0.98); }
    .btn:focus-visible { outline: none; box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--brand-primary); }
    .btn .ico { width: 16px; height: 16px; }
    .btn.primary { background-image: var(--brand-gradient); border: none; color: white; box-shadow: var(--shadow-md); }
    .btn.primary:hover { filter: brightness(1.1); }
    .btn.warn { background-color: #422006; border-color: #78350f; color: var(--warn-primary); }
    .btn.warn:hover { background-color: #522a08; }
    .btn.ghost { background-color: transparent; border-color: transparent; color: var(--text-secondary); }
    .btn.ghost:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
    .table-wrapper { overflow: auto; border: 1px solid var(--border-primary); border-radius: var(--radius-lg); }
    table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
    th, td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid var(--border-primary); white-space: nowrap; }
    thead th { position: sticky; top: 0; background-color: var(--bg-tertiary); font-weight: 600; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-secondary); z-index: 2; }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:hover { background-color: #2c2c2c; }
    .group-row td { position: sticky; top: 48px; background-color: #222222; font-weight: 700; color: var(--brand-secondary); z-index: 1; }
    .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); }
    .mt-4 { margin-top: 1rem; }
    .modal-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(4px); z-index: 50; display: flex; align-items: center; justify-content: center; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
    .modal-overlay.visible { opacity: 1; visibility: visible; }
    .modal-content { background-color: var(--surface); border-radius: var(--radius-lg); border: 1px solid var(--border-primary); box-shadow: var(--shadow-lg); padding: 2rem; width: 100%; max-width: 400px; transform: scale(0.95); transition: transform 0.3s; }
    .modal-overlay.visible .modal-content { transform: scale(1); }
    .modal-content h3 { font-family: var(--font-serif); margin: 0 0 0.5rem; font-size: 1.25rem; font-weight: 700; color: var(--brand-secondary); }
    .modal-content p { margin: 0 0 1.5rem; color: var(--text-secondary); }
    .modal-actions { display: flex; justify-content: flex-end; gap: 0.75rem; }
    #calendar-modal .modal-content { max-width: 340px; }
    .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
    .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; }
    .calendar-day, .calendar-weekday { display: flex; align-items: center; justify-content: center; height: 36px; border-radius: var(--radius-md); }
    .calendar-weekday { font-size: 0.75rem; font-weight: 600; color: var(--text-muted); }
    .calendar-day:not(.empty) { cursor: pointer; transition: background-color 0.2s; }
    .calendar-day:not(.empty):hover { background-color: var(--bg-tertiary); }
    .calendar-day.blackout { background-color: var(--brand-primary); color: var(--text-primary); font-weight: 600; }
    .calendar-day.selected { outline: 2px solid var(--brand-secondary); outline-offset: 2px; font-weight: 600; color: var(--brand-secondary); }
    .calendar-helper { margin-bottom: 1rem; font-size: 0.8rem; color: var(--text-secondary); }
    .date-input { cursor: pointer; }
    .date-input::placeholder { color: var(--text-muted); }
    @media (max-width: 1024px) { .app { grid-template-columns: 1fr; } .side { position: static; height: auto; border-right: none; border-bottom: 1px solid var(--border-primary); } .toolbar { margin: -2rem -2rem 0; } }
    @media (max-width: 768px) { .main { padding: 1.5rem; } .toolbar { margin: -1.5rem -1.5rem 0; } .g2, .g3, .g4 { grid-template-columns: 1fr; } .card .hd { flex-direction: column; align-items: flex-start; gap: 0.25rem; } }
  </style>
</head>
<body>

<div class="app">
  <aside class="side">
    <div class="brand">
      <img src="logo.png" alt="PGR Logo" class="logo">
      <div class="product">
        <h1>PGR New Starter Roster Creation Tool</h1>
        <div class="subbrand">Private Gaming Rooms</div>
        <div class="tagline">Let's train some newbies!</div>
        <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">Created by Patrick Price 2025</div>
        <div style="font-size: 10px; color: var(--text-muted); margin-top: 2px;">Version 10.5</div>
      </div>
    </div>
    <div class="nav-group">
      <h2>Roster Rules</h2>
      <div class="nav-chips"><div class="chip">One shift/day</div><div class="chip">No Sundays</div><div class="chip">Mon off</div><div class="chip">Min 15 shifts</div><div class="chip">≥2 off / 10d</div><div class="chip">Capacity 1/day/outlet</div><div class="chip">Start ≤20:00</div></div>
    </div>
  </aside>

  <main class="main">
    <div class="toolbar" role="region" aria-label="Global actions">
      <button id="buildAll" class="btn primary" type="button"><svg class="ico" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"/></svg>Build Roster</button>
      <button id="clearRosterBtn" class="btn" type="button">Clear Roster</button>
      <button id="exportAllCsv" class="btn" type="button"><svg class="ico" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>Export CSV</button>
      <button id="exportAllXls" class="btn" type="button"><svg class="ico" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10 21h7a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v11m0 5l4.879-4.879m0 0a3 3 0 104.243-4.242 3 3 0 00-4.243 4.242z"/></svg>Export Excel</button>
      <span id="conflicts" aria-live="polite">—</span>
    </div>

    <section class="card" aria-labelledby="starters-h">
      <div class="hd"><h2 id="starters-h">Step 1: Add New Team Members</h2><span class="sub">Add manually or import a CSV file</span></div>
      <div class="bd">
        <div class="grid g3">
          <div><label for="stName">Full Name</label><input id="stName" placeholder="Dakota Parata"></div>
          <div><label for="stId">Staff ID</label><input id="stId" placeholder="123456"></div>
          <div><label for="stDate">First Day of Work</label><input id="stDate" class="date-input" type="text" placeholder="Select a date" readonly aria-haspopup="dialog" aria-expanded="false"></div>
        </div>
        <div class="grid g4 mt-4">
          <button id="addStarter" class="btn primary" type="button">Add Person</button>
          <button id="importStartersBtn" class="btn" type="button">Import from CSV</button>
          <button id="exportStartersBtn" class="btn" type="button">Export to CSV</button>
          <button id="clearStarters" class="btn" type="button">Clear All People</button>
          <input type="file" id="importStarters" accept=".csv" class="visually-hidden" />
        </div>
        <div class="mt-4 table-wrapper">
          <table id="startersTbl">
            <thead><tr><th>#</th><th>Name</th><th>Staff ID</th><th>Start Date</th><th>Days Off</th><th>Actions</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="card" aria-labelledby="blocks-h">
      <div class="hd"><h2 id="blocks-h">Step 2: Set Training Shifts</h2><span class="sub">Set how many training shifts each person gets per area</span></div>
      <div class="bd">
        <div class="grid g3">
          <div><label for="blk_food">Oasis Food</label><input type="number" id="blk_food" value="3" min="0"></div>
          <div><label for="blk_obar">Oasis Bar</label><input type="number" id="blk_obar" value="2" min="0"></div>
          <div><label for="blk_floor">SOV South Floor</label><input type="number" id="blk_floor" value="3" min="0" title="Minimum 3 in a row enforced"></div>
          <div><label for="blk_nfloor">SOV North Floor</label><input type="number" id="blk_nfloor" value="1" min="0"></div>
          <div><label for="blk_bar">SOV South Bar</label><input type="number" id="blk_bar" value="1" min="0"></div>
          <div><label for="blk_dining">SOV Dining</label><input type="number" id="blk_dining" value="4" min="0"></div>
        </div>
        <div class="mt-4">
          <label>Randomize Shift Order?</label>
          <button id="shuffleBlocks" class="btn" type="button">Shuffle: OFF</button>
        </div>
      </div>
    </section>

    <section class="card" aria-labelledby="competency-h">
      <div class="hd"><h2 id="competency-h">Step 3: Configure Competency Checklists</h2><span class="sub">Load a template, connect team member data, and preview exports</span></div>
      <div class="bd">
        <div class="grid g3">
          <button id="loadDefaultCompetencies" class="btn" type="button">Use Default Template</button>
          <button id="importTemplateBtn" class="btn" type="button">Import Template JSON</button>
          <button id="importDatasetBtn" class="btn" type="button">Import Dataset JSON</button>
          <input type="file" id="importTemplateInput" accept=".json" class="visually-hidden" />
          <input type="file" id="importDatasetInput" accept=".json" class="visually-hidden" />
        </div>
        <div class="mt-4">
          <div id="templateSummary" style="font-size:0.85rem; color:var(--text-secondary);">No competency template loaded.</div>
          <div id="datasetSummary" style="font-size:0.85rem; color:var(--text-secondary); margin-top:0.5rem;">No competency dataset loaded.</div>
        </div>
        <div class="mt-4">
          <label for="checklistPreviewSelect">Preview Checklist For</label>
          <select id="checklistPreviewSelect"><option value="">Select a team member...</option></select>
        </div>
        <div id="checklistPreview" class="mt-4" style="border:1px solid var(--border-primary); border-radius:var(--radius-md); padding:1rem; background:var(--bg-tertiary); max-height:260px; overflow:auto; color:var(--text-secondary);">
          Load a template and dataset to preview individualized checklists.
        </div>
        <div class="grid g2 mt-4">
          <button id="exportChecklistCsv" class="btn" type="button">Export All Checklists (CSV)</button>
          <button id="exportChecklistXls" class="btn" type="button">Export All Checklists (Excel)</button>
          <button id="exportSelectedChecklistCsv" class="btn" type="button">Download Selected Checklist (CSV)</button>
          <button id="printChecklistBtn" class="btn" type="button">Print Checklist</button>
        </div>
      </div>
    </section>

    <section class="card" aria-labelledby="mandatory-h">
      <div class="hd"><h2 id="mandatory-h">Step 4: Session Days</h2><span class="sub">Choose days for mandatory sessions</span></div>
      <div class="bd">
        <div class="grid g3">
          <div><label for="welcomeDaySel">Welcome Day</label><select id="welcomeDaySel"><option value="1">Monday</option><option value="2" selected>Tuesday</option><option value="3">Wednesday</option><option value="4">Thursday</option><option value="5">Friday</option><option value="6">Saturday</option></select></div>
          <div><label for="onboardDaySel">PGR Onboarding</label><select id="onboardDaySel"><option value="1">Monday</option><option value="2">Tuesday</option><option value="3">Wednesday</option><option value="4" selected>Thursday</option><option value="5">Friday</option><option value="6">Saturday</option></select></div>
          <div><label for="elevateDaySel">Elevate Training</label><select id="elevateDaySel"><option value="1">Monday</option><option value="2">Tuesday</option><option value="3" selected>Wednesday</option><option value="4">Thursday</option><option value="5">Friday</option><option value="6">Saturday</option></select></div>
        </div>
      </div>
    </section>

    <section class="card" aria-labelledby="schedule-h">
      <div class="hd"><h2 id="schedule-h">Step 5: Generated Roster</h2><span class="sub">Click "Build Roster" to see the results here</span></div>
      <div class="bd" style="padding: 0;">
        <div class="table-wrapper">
          <table id="schedTbl">
            <thead><tr><th>Team Member</th><th>Staff ID</th><th>Date</th><th>Start</th><th>End</th><th>Outlet</th><th>Step</th><th>Shift</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>
</div>

<!-- Modals -->
<div id="modal" class="modal-overlay"><div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modal-title"><h3 id="modal-title"></h3><p id="modal-text"></p><div class="modal-actions"><button id="modal-cancel" class="btn">Cancel</button><button id="modal-confirm" class="btn primary">Confirm</button></div></div></div>
<div id="calendar-modal" class="modal-overlay"><div class="modal-content"><div class="calendar-header"><button id="prev-month" class="btn ghost" type="button">&lt;</button><h3 id="calendar-title"></h3><button id="next-month" class="btn ghost" type="button">&gt;</button></div><p id="calendar-helper" class="calendar-helper"></p><div class="calendar-grid" id="calendar-weekdays"></div><div class="calendar-grid" id="calendar-days"></div><div class="modal-actions" style="margin-top: 1rem;"><button id="calendar-close" class="btn primary" type="button">Done</button></div></div></div>

<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
</body>
<script>
// --- APP INITIALIZATION ---
window.onload = () => {
    // --- GLOBAL VARIABLES & CONSTANTS ---
    let starters = [];
    let allRows = [];
    let shuffle = false;
    let modalResolve;
    let activeStarterIndex = -1;
    let calendarContext = null;
    let currentCalendarDate = new Date();

    const MIN_SHIFTS = 15;
    const MANDATORY_SESSIONS = [
        { name: 'Welcome Day', label: 'Welcome Day', start: '09:00' },
        { name: 'PGR F&B On boarding', label: 'PGR F&B On boarding', start: '09:00' },
        { name: 'Elevate Training', label: 'Elevate Training', start: '09:00' }
    ];
    const RULES = {
        "Oasis Food": ["08:00", "11:00", "16:00"],
        "Oasis Bar": ["06:00", "08:00", "10:00", "14:00", "16:00", "17:00", "18:00", "19:00"],
        "SOV South Floor": Array.from({ length: 12 }, (_, k) => (9 + k).toString().padStart(2, '0') + ":00"),
        "SOV North Floor": ["18:00"],
        "SOV South Bar": ["06:00", "10:00", "14:00", "18:00"],
        "SOV Dining": ["17:00"]
    };
    const AVATARS = ['🦊', '🐼', '🦉', '🦁', '🐙', '🐳', '🦄', '🐲', '🌟', '🚀', '🎲', '🎯'];
    const AVATAR_TOOLTIP = 'This avatar is just for fun and has no effect on scheduling.';
    const DEFAULT_COMPETENCY_BUNDLE_URL = 'data/pgr_competency_checklist_bundle.json';
    const DEFAULT_COMPETENCY_BUNDLE_LABEL = 'PGR Competency Checklist (PDF)';
    const LEGACY_COMPETENCY_TEMPLATE_URL = 'data/competency-template.json';
    const LEGACY_COMPETENCY_DATASET_URL = 'data/competency-dataset.json';
    const STATIC_PGR_CHECKLIST_URL = 'pgr_competency_checklist.json';

    let competencyTemplate = null;
    let competencyDataset = null;
    let competencySource = { template: '', dataset: '' };
    let checklistMap = new Map();
    let selectedChecklistKey = '';
    let staticPgrChecklist = null;
    let staticPgrChecklistPromise = null;

    function getRandomAvatar() { return AVATARS[Math.floor(Math.random() * AVATARS.length)]; }
    function getAvatarMarkup(avatar) { return avatar ? `<span class="starter-avatar" title="${AVATAR_TOOLTIP}">${avatar}</span>` : ''; }

    // --- COMPETENCY CHECKLIST HELPERS ---
    const competencyTools = {};

    function getStarterKey(starter) {
        if (!starter) return '';
        const id = (starter.StaffID || '').trim();
        return id ? `id:${id.toLowerCase()}` : `name:${starter.Name.toLowerCase()}`;
    }

    function findDatasetEntry(starter) {
        if (!competencyDataset?.people) return null;
        const staffId = (starter.StaffID || '').trim().toLowerCase();
        if (staffId) {
            const byId = competencyDataset.people.find(p => (p.staffId || '').trim().toLowerCase() === staffId);
            if (byId) return byId;
        }
        return competencyDataset.people.find(p => (p.name || '').trim().toLowerCase() === starter.Name.trim().toLowerCase()) || null;
    }

    function applyPlaceholders(text, context) {
        if (!text) return '';
        return text.replace(/\{\{\s*([^}]+?)\s*\}\}/g, (_, key) => {
            const value = context[key.trim()];
            return value == null ? '' : String(value);
        });
    }

    function mapTemplateToStarter(template, starter, datasetEntry = {}, defaults = {}) {
        if (!template || !starter) return null;
        const isoStart = starter.StartDate || '';
        const startDateObj = isoStart ? parseYMD(isoStart) : null;
        const context = {
            name: starter.Name,
            staffId: starter.StaffID || '',
            startDate: isoStart,
            startDateDisplay: startDateObj ? toDMY(startDateObj) : '',
            role: datasetEntry.role || defaults.role || '',
            mentor: datasetEntry.mentor || defaults.mentor || '',
            department: datasetEntry.department || defaults.department || '',
            ...datasetEntry.context,
            ...defaults.context
        };
        const metadata = (template.metadataFields || []).map(field => ({
            key: field.key,
            label: field.label,
            value: datasetEntry[field.key] ?? defaults[field.key] ?? context[field.key] ?? ''
        }));
        const statusOptions = template.statusOptions || defaults.statusOptions || ['Not Started', 'In Progress', 'Complete'];
        const defaultStatus = template.defaultStatus || defaults.defaultStatus || statusOptions[0];
        const sections = (template.sections || []).map(section => {
            const items = (section.items || []).map(item => {
                const entry = datasetEntry?.competencies?.[item.id] || {};
                const itemStatus = entry.status || item.defaultStatus || defaultStatus;
                return {
                    id: item.id,
                    label: applyPlaceholders(item.label, context),
                    description: applyPlaceholders(item.description || '', context),
                    status: itemStatus,
                    statusOptions: item.statusOptions || statusOptions,
                    completedOn: entry.completedOn || item.completedOn || '',
                    notes: entry.notes || datasetEntry.notes || '',
                    evidence: entry.evidence || ''
                };
            });
            return {
                title: applyPlaceholders(section.title || '', context),
                description: applyPlaceholders(section.description || '', context),
                items
            };
        });
        return {
            title: template.title || 'Competency Checklist',
            version: template.version || '1.0',
            generatedOn: new Date().toISOString(),
            name: starter.Name,
            staffId: starter.StaffID || '',
            startDate: isoStart,
            metadata,
            sections
        };
    }

    function flattenChecklist(checklist) {
        if (!checklist) return [];
        const rows = [];
        for (const section of checklist.sections || []) {
            for (const item of section.items || []) {
                rows.push({
                    Name: checklist.name,
                    StaffID: checklist.staffId || '',
                    Section: section.title || '',
                    Item: item.label || '',
                    Status: item.status || '',
                    CompletedOn: item.completedOn || '',
                    Notes: item.notes || '',
                    Evidence: item.evidence || ''
                });
            }
        }
        return rows;
    }

    function flattenChecklistCollection(checklists) {
        const rows = [];
        for (const cl of checklists.values()) {
            rows.push(...flattenChecklist(cl));
        }
        return rows;
    }

    function humanizeKey(key) {
        if (!key) return '';
        return key
            .split('_')
            .filter(Boolean)
            .map(part => {
                if (part.length <= 3 && part === part.toUpperCase()) return part;
                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
            })
            .join(' ');
    }

    function normalizePgrChecklist(raw) {
        if (!raw || typeof raw !== 'object') throw new Error('Checklist file was empty or invalid.');
        const root = raw.PGR_Competency_Checklist;
        if (!root || typeof root !== 'object') throw new Error('Checklist file missing "PGR_Competency_Checklist" root.');

        const meta = root.Meta && typeof root.Meta === 'object' ? { ...root.Meta } : {};
        const startShiftMeta = {};
        const sections = [];

        const pushArraySection = (category, subcategory, arr) => {
            if (!Array.isArray(arr) || !arr.length) return;
            sections.push({
                category,
                subcategory: subcategory || '',
                items: arr.map(item => ({ label: (item == null ? '' : String(item)).trim(), detail: '' }))
            });
        };

        const startingShift = root.Starting_Shift;
        if (startingShift && typeof startingShift === 'object') {
            for (const [key, value] of Object.entries(startingShift)) {
                if (Array.isArray(value)) {
                    pushArraySection('Starting Shift', humanizeKey(key), value);
                } else {
                    startShiftMeta[humanizeKey(key)] = value == null ? '' : String(value);
                }
            }
        }

        const importantLocations = root.Important_Locations;
        if (importantLocations && typeof importantLocations === 'object') {
            const items = Object.entries(importantLocations).map(([key, value]) => ({
                label: humanizeKey(key),
                detail: value == null ? '' : String(value)
            }));
            if (items.length) {
                sections.push({ category: 'Important Locations', subcategory: '', items });
            }
        }

        pushArraySection('Bepoz Cash Handling', '', root.Bepoz_Cash_Handling);

        const bars = root.Bars;
        if (bars && typeof bars === 'object') {
            for (const [key, value] of Object.entries(bars)) {
                pushArraySection('Bars', humanizeKey(key), value);
            }
        }

        pushArraySection('Bar Knowledge', '', root.Bar_Knowledge);
        pushArraySection('Food Offerings', '', root.Food_Offerings);
        pushArraySection('Floor', '', root.Floor);
        pushArraySection('BOH Cleaning Duties', '', root.BOH_Cleaning_Duties);

        return { meta, startShiftMeta, sections };
    }

    async function ensureStaticPgrChecklist() {
        if (staticPgrChecklist) return staticPgrChecklist;
        if (!staticPgrChecklistPromise) {
            staticPgrChecklistPromise = fetchJson(STATIC_PGR_CHECKLIST_URL)
                .then(normalizePgrChecklist)
                .then(parsed => {
                    staticPgrChecklist = parsed;
                    return parsed;
                })
                .catch(error => {
                    staticPgrChecklistPromise = null;
                    throw error;
                });
        }
        return staticPgrChecklistPromise;
    }

    function buildStaticChecklistSheet(template, starter, index = 0) {
        if (!template || !starter) {
            return {
                sheetRows: [],
                overviewRows: [],
                metaStartRow: 0,
                metaEndRow: 0,
                headerRowIndex: 0,
                dataStartRow: 0,
                columnCount: 0,
                columnWidths: []
            };
        }
        const displayName = (starter.Name && starter.Name.trim()) || `Starter ${index + 1}`;
        const isoStart = starter.StartDate || '';
        const startDate = isoStart ? toDMY(parseYMD(isoStart)) : '';
        const generatedOn = toDMY(new Date());

        const metaRows = [
            ['Team Member', displayName],
            ['Staff ID', starter.StaffID || ''],
            ['Start Date', startDate],
            ['Checklist Generated On', generatedOn]
        ];

        const templateMeta = template.meta || {};
        const checklistName = templateMeta.Name || displayName;
        const checklistDate = templateMeta.Date || startDate || generatedOn;
        if (templateMeta.Author) metaRows.push(['Template Author', templateMeta.Author]);
        if (templateMeta.Created) metaRows.push(['Template Created', templateMeta.Created]);
        if (checklistName) metaRows.push(['Checklist Name', checklistName]);
        if (checklistDate) metaRows.push(['Checklist Date', checklistDate]);
        const startShiftMeta = template.startShiftMeta || {};
        for (const [label, value] of Object.entries(startShiftMeta)) {
            metaRows.push([`Starting Shift ${label}`, value || '']);
        }

        const sheetRows = [['PGR Competency Checklist']];
        sheetRows.push([]);
        const metaStartRow = sheetRows.length;
        for (const row of metaRows) sheetRows.push(row);
        const metaEndRow = sheetRows.length - 1;
        sheetRows.push([]);

        const header = ['Category', 'Subcategory', 'Item', 'Details', 'Status', 'Completed On', 'Notes', 'Evidence'];
        const headerRowIndex = sheetRows.length;
        sheetRows.push(header);

        const dataStartRow = sheetRows.length;
        const overviewRows = [];
        for (const section of template.sections || []) {
            const sectionName = section.category || '';
            const subsection = section.subcategory || '';
            for (const item of section.items || []) {
                const label = item.label || '';
                const detail = item.detail || '';
                sheetRows.push([sectionName, subsection, label, detail, '', '', '', '']);
                overviewRows.push({
                    Starter: displayName,
                    StaffID: starter.StaffID || '',
                    StartDate: startDate,
                    Category: sectionName,
                    Subcategory: subsection,
                    Item: label,
                    Details: detail
                });
            }
        }

        return {
            sheetRows,
            overviewRows,
            metaStartRow,
            metaEndRow,
            headerRowIndex,
            dataStartRow,
            columnCount: header.length,
            columnWidths: [22, 24, 38, 38, 16, 18, 28, 26]
        };
    }

    function sanitizeSheetName(name) {
        const invalid = /[\[\]\*\/\\\?:]/g;
        let sanitized = (name || '').replace(invalid, ' ').replace(/\s+/g, ' ').trim();
        if (!sanitized) sanitized = 'Sheet';
        if (sanitized.length > 31) sanitized = sanitized.slice(0, 31);
        return sanitized;
    }

    function makeUniqueSheetName(base, usedNames) {
        const sanitizedBase = sanitizeSheetName(base);
        let candidate = sanitizedBase;
        let counter = 1;
        while (usedNames.has(candidate)) {
            counter += 1;
            const suffix = ` ${counter}`;
            const trimmed = sanitizedBase.slice(0, Math.max(0, 31 - suffix.length));
            candidate = sanitizeSheetName(`${trimmed}${suffix}`);
        }
        usedNames.add(candidate);
        return candidate;
    }

    function buildChecklistSheetName(starter, index, usedNames) {
        const baseSegment = (starter?.Name && starter.Name.trim()) || `Starter ${index + 1}`;
        const base = `Checklist ${baseSegment}`;
        return makeUniqueSheetName(base, usedNames);
    }

    competencyTools.mapTemplateToStarter = mapTemplateToStarter;
    competencyTools.flattenChecklist = flattenChecklist;
    competencyTools.flattenChecklistCollection = flattenChecklistCollection;
    competencyTools.normalizePgrChecklist = normalizePgrChecklist;
    competencyTools.buildStaticChecklistSheet = buildStaticChecklistSheet;
    window.__competencyTools = competencyTools;

    function describeTemplate(template) {
        if (!template) return 'No competency template loaded.';
        const sectionCount = (template.sections || []).length;
        return `${template.title || 'Template'} (v${template.version || '1.0'}) • ${sectionCount} section${sectionCount === 1 ? '' : 's'}`;
    }

    function describeDataset(dataset) {
        if (!dataset) return 'No competency dataset loaded.';
        const personCount = (dataset.people || []).length;
        const version = dataset.templateVersion ? `v${dataset.templateVersion}` : 'unversioned';
        return `Dataset ${version} • ${personCount} record${personCount === 1 ? '' : 's'}`;
    }

    function csvEscape(value) {
        if (value == null) return '';
        const str = String(value).replace(/"/g, '""');
        return /[",\n]/.test(str) ? `"${str}"` : str;
    }

    function buildChecklistHtml(checklist, { compact = false } = {}) {
        if (!checklist) return '<p>No checklist available.</p>';
        const metaHtml = (checklist.metadata || []).map(m => `<div style="margin-bottom:0.25rem;"><strong>${m.label}:</strong> ${m.value || '—'}</div>`).join('');
        const sectionHtml = (checklist.sections || []).map(section => {
            const items = (section.items || []).map(item => {
                return `<li style="margin-bottom:0.35rem;"><div><strong>${item.label}</strong> <span style="color:var(--brand-secondary, #D4AF37);">${item.status || '—'}</span></div>${item.description ? `<div style="font-size:0.75rem; color:var(--text-muted, #737373);">${item.description}</div>` : ''}${item.completedOn ? `<div style="font-size:0.75rem; color:var(--text-muted, #737373);">Completed: ${item.completedOn}</div>` : ''}${item.notes ? `<div style="font-size:0.75rem; color:var(--text-muted, #737373);">Notes: ${item.notes}</div>` : ''}</li>`;
            }).join('');
            return `<section style="margin-top:1rem;"><h4 style="margin:0 0 0.5rem; font-size:${compact ? '0.85rem' : '1rem'}; color:var(--text-primary, #f5f5f5);">${section.title}</h4>${section.description ? `<p style="margin:0 0 0.5rem; font-size:0.8rem; color:var(--text-secondary, #a3a3a3);">${section.description}</p>` : ''}<ul style="padding-left:1rem; margin:0; list-style:disc;">${items || '<li>No items configured.</li>'}</ul></section>`;
        }).join('');
        return `<article style="background:var(--surface, #1f1f1f); border:1px solid var(--border-primary, #404040); border-radius:var(--radius-md, 12px); padding:${compact ? '0.75rem' : '1rem'}; margin-bottom:1rem;"><header style="margin-bottom:0.75rem;"><h3 style="margin:0; color:var(--brand-secondary, #D4AF37); font-size:${compact ? '1rem' : '1.15rem'};">${checklist.name}</h3><div style="font-size:0.8rem; color:var(--text-muted, #737373);">Staff ID: ${checklist.staffId || 'N/A'} • Start: ${checklist.startDate ? toDMY(parseYMD(checklist.startDate)) : 'TBC'} • Template v${checklist.version}</div></header><div style="font-size:0.8rem; color:var(--text-secondary, #a3a3a3);">${metaHtml || '<em>No additional metadata</em>'}</div>${sectionHtml}</article>`;
    }

    function updateChecklistSummaries() {
        const templateSummary = byId('templateSummary');
        const datasetSummary = byId('datasetSummary');
        if (templateSummary) templateSummary.textContent = competencyTemplate ? `${describeTemplate(competencyTemplate)}${competencySource.template ? ` • ${competencySource.template}` : ''}` : 'No competency template loaded.';
        if (datasetSummary) datasetSummary.textContent = competencyDataset ? `${describeDataset(competencyDataset)}${competencySource.dataset ? ` • ${competencySource.dataset}` : ''}` : 'No competency dataset loaded.';
    }

    function updateChecklistSelect() {
        const select = byId('checklistPreviewSelect');
        if (!select) return;
        const previousValue = selectedChecklistKey;
        select.innerHTML = '<option value="">Select a team member...</option>';
        for (const starter of starters) {
            const key = getStarterKey(starter);
            const option = document.createElement('option');
            option.value = key;
            option.textContent = starter.StaffID ? `${starter.Name} • ${starter.StaffID}` : starter.Name;
            if (!checklistMap.has(key)) option.disabled = !competencyTemplate;
            select.appendChild(option);
        }
        if (previousValue && checklistMap.has(previousValue)) {
            select.value = previousValue;
        } else {
            select.value = '';
        }
    }

    function renderChecklistPreview(checklist) {
        const preview = byId('checklistPreview');
        if (!preview) return;
        if (!competencyTemplate) {
            preview.innerHTML = 'Load a template and dataset to preview individualized checklists.';
            return;
        }
        if (!checklist) {
            preview.innerHTML = starters.length ? 'Select a team member to preview their checklist.' : 'Add team members to generate personalized checklists.';
            return;
        }
        preview.innerHTML = buildChecklistHtml(checklist, { compact: true });
    }

    function syncChecklists() {
        checklistMap = new Map();
        if (!competencyTemplate) {
            updateChecklistSelect();
            renderChecklistPreview(null);
            return;
        }
        const defaults = competencyDataset?.defaults || {};
        for (const starter of starters) {
            const entry = findDatasetEntry(starter) || {};
            const key = getStarterKey(starter);
            const checklist = mapTemplateToStarter(competencyTemplate, starter, entry, defaults);
            checklistMap.set(key, checklist);
        }
        updateChecklistSelect();
        if (selectedChecklistKey && !checklistMap.has(selectedChecklistKey)) selectedChecklistKey = '';
        if (!selectedChecklistKey && starters.length) {
            const firstKey = getStarterKey(starters[0]);
            if (checklistMap.has(firstKey)) selectedChecklistKey = firstKey;
        }
        const select = byId('checklistPreviewSelect');
        if (select) select.value = selectedChecklistKey || '';
        renderChecklistPreview(selectedChecklistKey ? checklistMap.get(selectedChecklistKey) : null);
    }

    function exportAllChecklistsCsv() {
        if (!checklistMap.size) { showModal('Export Error', 'Load a template and add starters before exporting.'); return; }
        const rows = flattenChecklistCollection(checklistMap);
        if (!rows.length) { showModal('Export Error', 'No checklist rows available to export.'); return; }
        const header = ['Name', 'StaffID', 'Section', 'Item', 'Status', 'CompletedOn', 'Notes', 'Evidence'];
        const csv = [header.join(',')].concat(rows.map(row => header.map(col => csvEscape(row[col])).join(','))).join('\n');
        download('competency-checklists.csv', csv);
    }

    function exportSelectedChecklistCsv() {
        if (!selectedChecklistKey || !checklistMap.has(selectedChecklistKey)) {
            showModal('Export Error', 'Select a team member to export their checklist.');
            return;
        }
        const checklist = checklistMap.get(selectedChecklistKey);
        const rows = flattenChecklist(checklist);
        if (!rows.length) { showModal('Export Error', 'The selected checklist has no items to export.'); return; }
        const header = ['Name', 'StaffID', 'Section', 'Item', 'Status', 'CompletedOn', 'Notes', 'Evidence'];
        const csv = [header.join(',')].concat(rows.map(row => header.map(col => csvEscape(row[col])).join(','))).join('\n');
        download(`${checklist.name.replace(/[^a-z0-9]+/gi, '_').toLowerCase()}_competency.csv`, csv);
    }

    const EXCEL_THEME = {
        primary: 'FFB92B27',
        secondary: 'FFD4AF37',
        headerFont: 'FFFFFFFF',
        titleFont: 'FFFFFFFF',
        textDark: 'FF1F2933',
        zebraLight: 'FFFFF8F3',
        zebraDark: 'FFFFFFFF',
        metaValueFill: 'FFFFFBF7',
        border: 'FFE5E7EB'
    };

    function buildBorder(color = EXCEL_THEME.border) {
        return {
            top: { style: 'thin', color: { rgb: color } },
            right: { style: 'thin', color: { rgb: color } },
            bottom: { style: 'thin', color: { rgb: color } },
            left: { style: 'thin', color: { rgb: color } }
        };
    }

    function setCellStyle(ws, row, col, styleFactory, blankValue = '') {
        const address = XLSX.utils.encode_cell({ r: row, c: col });
        let cell = ws[address];
        if (!cell) {
            cell = { t: 's', v: blankValue };
            ws[address] = cell;
        }
        const style = typeof styleFactory === 'function' ? styleFactory() : styleFactory;
        cell.s = style;
    }

    function createTitleStyle() {
        return {
            font: { name: 'Segoe UI Semibold', sz: 16, bold: true, color: { rgb: EXCEL_THEME.titleFont } },
            alignment: { horizontal: 'center', vertical: 'center' },
            fill: { patternType: 'solid', fgColor: { rgb: EXCEL_THEME.primary } }
        };
    }

    function createHeaderStyle() {
        return {
            font: { name: 'Segoe UI Semibold', sz: 11, bold: true, color: { rgb: EXCEL_THEME.headerFont } },
            alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
            fill: { patternType: 'solid', fgColor: { rgb: EXCEL_THEME.primary } },
            border: buildBorder()
        };
    }

    function createMetaLabelStyle() {
        return {
            font: { name: 'Segoe UI', sz: 10, bold: true, color: { rgb: EXCEL_THEME.textDark } },
            alignment: { horizontal: 'left', vertical: 'center' },
            fill: { patternType: 'solid', fgColor: { rgb: EXCEL_THEME.secondary } },
            border: buildBorder()
        };
    }

    function createMetaValueStyle() {
        return {
            font: { name: 'Segoe UI', sz: 10, color: { rgb: EXCEL_THEME.textDark } },
            alignment: { horizontal: 'left', vertical: 'center', wrapText: true },
            fill: { patternType: 'solid', fgColor: { rgb: EXCEL_THEME.metaValueFill } },
            border: buildBorder()
        };
    }

    function createDataStyle(isAlternate) {
        return {
            font: { name: 'Segoe UI', sz: 10, color: { rgb: EXCEL_THEME.textDark } },
            alignment: { vertical: 'center', wrapText: true },
            fill: { patternType: 'solid', fgColor: { rgb: isAlternate ? EXCEL_THEME.zebraLight : EXCEL_THEME.zebraDark } },
            border: buildBorder()
        };
    }

    function ensureColumnWidths(columnCount, columnWidths = []) {
        const widths = [];
        for (let i = 0; i < columnCount; i++) {
            widths.push({ wch: columnWidths[i] ?? 20 });
        }
        return widths;
    }

    function styleChecklistWorksheet(ws, {
        columnCount,
        columnWidths = [],
        titleRowIndex = 0,
        headerRowIndex,
        metaStartRow,
        metaEndRow,
        dataStartRow
    } = {}) {
        if (!ws || !ws['!ref']) return;
        const range = XLSX.utils.decode_range(ws['!ref']);
        const colCount = columnCount || (range.e.c - range.s.c + 1);
        ws['!cols'] = ensureColumnWidths(colCount, columnWidths);

        if (typeof titleRowIndex === 'number') {
            ws['!merges'] = ws['!merges'] || [];
            ws['!merges'].push({ s: { r: titleRowIndex, c: 0 }, e: { r: titleRowIndex, c: colCount - 1 } });
            setCellStyle(ws, titleRowIndex, 0, createTitleStyle);
            ws['!rows'] = ws['!rows'] || [];
            ws['!rows'][titleRowIndex] = { hpt: 28 };
        }

        if (typeof metaStartRow === 'number' && typeof metaEndRow === 'number' && metaEndRow >= metaStartRow) {
            for (let r = metaStartRow; r <= metaEndRow; r++) {
                setCellStyle(ws, r, 0, createMetaLabelStyle);
                setCellStyle(ws, r, 1, createMetaValueStyle);
            }
        }

        if (typeof headerRowIndex === 'number') {
            for (let c = 0; c < colCount; c++) {
                setCellStyle(ws, headerRowIndex, c, createHeaderStyle);
            }
            ws['!rows'] = ws['!rows'] || [];
            ws['!rows'][headerRowIndex] = { hpt: 22 };
        }

        if (typeof dataStartRow === 'number') {
            const lastRow = range.e.r;
            if (dataStartRow <= lastRow) {
                for (let r = dataStartRow; r <= lastRow; r++) {
                    const isAlternate = (r - dataStartRow) % 2 === 0;
                    for (let c = 0; c < colCount; c++) {
                        setCellStyle(ws, r, c, () => createDataStyle(isAlternate));
                    }
                }
            }
        }
    }

    function styleTabularWorksheet(ws, {
        columnWidths = [],
        headerRowIndex = 0,
        dataStartRow = headerRowIndex + 1
    } = {}) {
        if (!ws || !ws['!ref']) return;
        const range = XLSX.utils.decode_range(ws['!ref']);
        const columnCount = range.e.c - range.s.c + 1;
        ws['!cols'] = ensureColumnWidths(columnCount, columnWidths);

        if (typeof headerRowIndex === 'number') {
            for (let c = 0; c < columnCount; c++) {
                setCellStyle(ws, headerRowIndex, c, createHeaderStyle);
            }
            ws['!rows'] = ws['!rows'] || [];
            ws['!rows'][headerRowIndex] = { hpt: 22 };
        }

        if (typeof dataStartRow === 'number') {
            const lastRow = range.e.r;
            if (dataStartRow <= lastRow) {
                for (let r = dataStartRow; r <= lastRow; r++) {
                    const isAlternate = (r - dataStartRow) % 2 === 0;
                    for (let c = 0; c < columnCount; c++) {
                        setCellStyle(ws, r, c, () => createDataStyle(isAlternate));
                    }
                }
            }
        }
    }

    function exportAllChecklistsXls() {
        if (!checklistMap.size) { showModal('Export Error', 'Load a template and add starters before exporting.'); return; }
        if (typeof XLSX === 'undefined') {
            showModal('Export Error', 'Excel export functionality is not available. The required library could not be loaded.');
            return;
        }
        const wb = XLSX.utils.book_new();
        const formattingQueue = [];

        const allRows = flattenChecklistCollection(checklistMap);
        if (allRows.length) {
            const formattedAllRows = allRows.map(row => ({
                'Name': row.Name,
                'Staff ID': row.StaffID || '',
                'Section': row.Section,
                'Item': row.Item,
                'Status': row.Status,
                'Completed On': row.CompletedOn,
                'Notes': row.Notes,
                'Evidence': row.Evidence
            }));
            const allHeaders = ['Name', 'Staff ID', 'Section', 'Item', 'Status', 'Completed On', 'Notes', 'Evidence'];
            const wsAll = XLSX.utils.json_to_sheet(formattedAllRows, { header: allHeaders });
            const sheetName = 'All Checklists';
            XLSX.utils.book_append_sheet(wb, wsAll, sheetName);
            formattingQueue.push({
                sheetName,
                type: 'table',
                options: {
                    columnWidths: [26, 18, 26, 44, 16, 20, 36, 28],
                    headerRowIndex: 0,
                    dataStartRow: 1
                }
            });
        }

        for (const checklist of checklistMap.values()) {
            const rows = flattenChecklist(checklist);
            const generated = checklist.generatedOn ? new Date(checklist.generatedOn) : null;
            const formattedGenerated = generated && Number.isFinite(generated.getTime()) ? toDMY(generated) : (checklist.generatedOn || '');
            const baseMetaRows = [
                ['Team Member', checklist.name],
                ['Staff ID', checklist.staffId || ''],
                ['Start Date', checklist.startDate ? toDMY(parseYMD(checklist.startDate)) : ''],
                ['Template Version', checklist.version || ''],
                ['Checklist Generated On', formattedGenerated]
            ];
            for (const meta of checklist.metadata || []) {
                baseMetaRows.push([meta.label, meta.value || '']);
            }

            const matrix = [['PGR Competency Checklist'], []];
            const metaStartRow = matrix.length;
            for (const row of baseMetaRows) matrix.push(row);
            const metaEndRow = matrix.length - 1;
            matrix.push([]);
            const headerRowIndex = matrix.length;
            const headerRow = ['Section', 'Item', 'Status', 'Completed On', 'Notes', 'Evidence'];
            matrix.push(headerRow);
            const dataStartRow = matrix.length;
            for (const row of rows) {
                matrix.push([row.Section, row.Item, row.Status, row.CompletedOn, row.Notes, row.Evidence]);
            }

            const ws = XLSX.utils.aoa_to_sheet(matrix);
            let sheetName = checklist.name || 'Checklist';
            if (sheetName.length > 28) sheetName = sheetName.slice(0, 28);
            XLSX.utils.book_append_sheet(wb, ws, sheetName);
            formattingQueue.push({
                sheetName,
                type: 'checklist',
                options: {
                    columnCount: headerRow.length,
                    columnWidths: [26, 42, 18, 20, 34, 28],
                    titleRowIndex: 0,
                    metaStartRow,
                    metaEndRow,
                    headerRowIndex,
                    dataStartRow
                }
            });
        }

        for (const cfg of formattingQueue) {
            const ws = wb.Sheets[cfg.sheetName];
            if (!ws) continue;
            if (cfg.type === 'table') {
                styleTabularWorksheet(ws, cfg.options);
            } else if (cfg.type === 'checklist') {
                styleChecklistWorksheet(ws, cfg.options);
            }
        }

        XLSX.writeFile(wb, 'competency-checklists.xlsx');
    }

    function printChecklists() {
        if (!checklistMap.size) { showModal('Print Error', 'Load a template and add starters before printing.'); return; }
        const targets = selectedChecklistKey && checklistMap.has(selectedChecklistKey) ? [checklistMap.get(selectedChecklistKey)] : Array.from(checklistMap.values());
        const html = `<!doctype html><html><head><meta charset="utf-8"><title>Competency Checklists</title><style>body{font-family:${getComputedStyle(document.body).fontFamily};background:#fff;color:#111;padding:32px;}h1{margin-top:0;}article{page-break-inside:avoid;box-shadow:none;border:1px solid #ccc;padding:16px;margin-bottom:24px;border-radius:8px;}section{margin-top:16px;}ul{padding-left:18px;}li{margin-bottom:8px;font-size:14px;}header{margin-bottom:12px;}@media print{body{padding:0;}article{border:none;}}</style></head><body><h1>Competency Checklists</h1>${targets.map(cl => buildChecklistHtml(cl, { compact: false })).join('<hr>')}</body></html>`;
        const win = window.open('', '_blank');
        if (!win) { showModal('Print Error', 'Pop-up blocked. Please enable pop-ups to print.'); return; }
        win.document.write(html);
        win.document.close();
        win.focus();
        win.print();
    }

    async function fetchText(url) {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Failed to load ${url}: ${res.status}`);
        return res.text();
    }

    async function fetchJson(url) {
        const text = await fetchText(url);
        try {
            return JSON.parse(text);
        } catch (error) {
            throw new Error(`Failed to parse JSON from ${url}: ${error.message || error}`);
        }
    }

    async function fetchCompetencyBundle(url) {
        const bundle = await fetchJson(url);
        if (!bundle || typeof bundle !== 'object') {
            throw new Error('Bundle response was empty');
        }
        if (!bundle.template || !bundle.dataset) {
            throw new Error('Bundle missing template or dataset fields');
        }
        return bundle;
    }

    function setCompetencyTemplate(template, sourceLabel = '') {
        competencyTemplate = template;
        competencySource.template = sourceLabel;
        updateChecklistSummaries();
    }

    function setCompetencyDataset(dataset, sourceLabel = '') {
        competencyDataset = dataset;
        competencySource.dataset = sourceLabel;
        updateChecklistSummaries();
    }

    async function loadDefaultCompetencies() {
        let bundleError = null;
        try {
            const bundle = await fetchCompetencyBundle(DEFAULT_COMPETENCY_BUNDLE_URL);
            const dataset = bundle.dataset;
            const bundleLabel = bundle.bundle || DEFAULT_COMPETENCY_BUNDLE_LABEL;
            setCompetencyTemplate(bundle.template, `Default bundle (${bundleLabel})`);
            const datasetLabel = dataset.templateVersion
                ? `${bundleLabel} (v${dataset.templateVersion})`
                : bundleLabel;
            setCompetencyDataset(dataset, datasetLabel);
            syncChecklists();
            return;
        } catch (error) {
            bundleError = error;
            console.warn('Default competency bundle failed, attempting legacy assets:', error);
        }

        try {
            const [template, dataset] = await Promise.all([
                fetchJson(LEGACY_COMPETENCY_TEMPLATE_URL),
                fetchJson(LEGACY_COMPETENCY_DATASET_URL)
            ]);
            setCompetencyTemplate(template, 'Legacy default bundle');
            setCompetencyDataset(dataset, dataset.templateVersion ? `Legacy bundle (${dataset.templateVersion})` : 'Legacy bundle');
            syncChecklists();
        } catch (error) {
            console.error('Default competency load failed:', error);
            const reason = bundleError ? `Bundle: ${bundleError.message || bundleError}.` : '';
            showModal('Load Error', `Unable to load the default competency assets.${reason ? ` ${reason}` : ''} Please try importing them manually.`);
        }
    }

    function readJsonFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    resolve(JSON.parse(reader.result));
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = () => reject(reader.error || new Error('Unable to read file.'));
            reader.readAsText(file);
        });
    }

    async function handleTemplateImport(event) {
        const file = event.target.files?.[0];
        event.target.value = '';
        if (!file) return;
        try {
            const template = await readJsonFile(file);
            setCompetencyTemplate(template, `Imported (${file.name})`);
            syncChecklists();
        } catch (error) {
            console.error('Template import failed:', error);
            showModal('Template Error', 'The selected template file is not valid JSON.');
        }
    }

    async function handleDatasetImport(event) {
        const file = event.target.files?.[0];
        event.target.value = '';
        if (!file) return;
        try {
            const dataset = await readJsonFile(file);
            setCompetencyDataset(dataset, `Imported (${file.name})`);
            syncChecklists();
        } catch (error) {
            console.error('Dataset import failed:', error);
            showModal('Dataset Error', 'The selected dataset file is not valid JSON.');
        }
    }

    function handleChecklistSelectionChange(event) {
        selectedChecklistKey = event.target.value || '';
        renderChecklistPreview(selectedChecklistKey ? checklistMap.get(selectedChecklistKey) : null);
    }

    // --- HELPER FUNCTIONS ---
    const byId = id => document.getElementById(id);
    const pad2 = n => (n < 10 ? "0" : "") + n;
    const toYMD = d => `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    const toDMY = d => `${pad2(d.getDate())}/${pad2(d.getMonth() + 1)}/${d.getFullYear()}`;
    const parseYMD = s => { const [y, m, d] = s.split('-').map(Number); return new Date(y, m - 1, d); };
    const stDateInput = byId('stDate');
    function setStartDateISO(iso) {
        if (iso) {
            stDateInput.dataset.iso = iso;
            stDateInput.value = toDMY(parseYMD(iso));
        } else {
            stDateInput.dataset.iso = '';
            stDateInput.value = '';
        }
    }
    function getStartDateISO() { return stDateInput.dataset.iso || ''; }
    const isMon = d => d.getDay() === 1;
    const isSun = d => d.getDay() === 0;
    const nextWorking = d => { let x = new Date(d); while (isSun(x) || isMon(x)) x.setDate(x.getDate() + 1); return x; };
    function addWorkDay(d) { const x = new Date(d); x.setDate(x.getDate() + 1); return nextWorking(x); }
    function nextDow(startDate, dow, includeStart = true) { const d = new Date(startDate); if (!includeStart) d.setDate(d.getDate() + 1); while (d.getDay() !== dow) d.setDate(d.getDate() + 1); return d; }
    function shuffled(arr) { const a = arr.slice(); for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; }
    function isOutletAllowedOnDate(outlet, dateObj) { const dow = dateObj.getDay(); if (dow === 0) return false; if (outlet === "SOV North Floor") return (dow === 5 || dow === 6); return true; }

    // --- MODAL FUNCTIONS ---
    function showModal(title, text, showCancel = false) {
        const modal = byId('modal');
        byId('modal-title').textContent = title;
        byId('modal-text').textContent = text;
        byId('modal-cancel').style.display = showCancel ? 'inline-flex' : 'none';
        modal.classList.add('visible');
        return new Promise(resolve => { modalResolve = resolve; });
    }

    // --- CORE ROSTERING FUNCTIONS ---
    function isMandatory(r) { 
        const mandatoryLabels = new Set(MANDATORY_SESSIONS.map((s) => s.label));
        return mandatoryLabels.has(r.Outlet);
    }
    function shiftsInLastNDaysFor(starterName, dateObj, n) {
        const start = new Date(dateObj); start.setDate(start.getDate() - (n - 1));
        const startKey = toYMD(start), endKey = toYMD(dateObj);
        let count = 0;
        for (const r of allRows) {
            if (r.Starter !== starterName) continue;
            if (isMandatory(r)) continue;
            if (r.Date >= startKey && r.Date <= endKey) count++;
        }
        return count;
    }
    function canWorkThisDay(starterName, dateObj) { return shiftsInLastNDaysFor(starterName, dateObj, 10) < 8; }

    function lastShiftEnd(starterName) {
        let last = null;
        for (const r of allRows) {
            if (r.Starter !== starterName) continue;
            const d = parseYMD(r.Date);
            const [hh, mm] = r.End.split(":").map(Number);
            d.setHours(hh, mm, 0, 0);
            if (!last || d > last) last = d;
        }
        return last;
    }
    function hasMinRest(starterName, dateObj, startTime) {
        const last = lastShiftEnd(starterName);
        if (!last) return true;
        const start = new Date(dateObj);
        const [hh, mm] = startTime.split(":").map(Number);
        start.setHours(hh, mm, 0, 0);
        return (start - last) >= 12 * 60 * 60 * 1000;
    }

    // --- CALENDAR FUNCTIONS ---
    function renderCalendar() {
        if (!calendarContext) return;
        const calendarTitle = byId('calendar-title');
        const calendarDays = byId('calendar-days');
        const weekdaysContainer = byId('calendar-weekdays');
        const helper = byId('calendar-helper');
        const { mode } = calendarContext;
        let starter = null;
        if (mode === 'blackout') {
            starter = starters[activeStarterIndex];
            if (!starter) return;
            helper.textContent = `Toggle blackout days for ${starter.Name}.`;
        } else if (mode === 'startDate') {
            helper.textContent = 'Choose the starter\'s first day of work.';
        } else {
            helper.textContent = '';
            return;
        }

        const year = currentCalendarDate.getFullYear();
        const month = currentCalendarDate.getMonth();
        calendarTitle.textContent = `${currentCalendarDate.toLocaleString('default', { month: 'long' })} ${year}`;
        calendarDays.innerHTML = '';
        weekdaysContainer.innerHTML = ['S', 'M', 'T', 'W', 'T', 'F', 'S'].map(d => `<div class="calendar-weekday">${d}</div>`).join('');
        const firstDayOfMonth = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        for (let i = 0; i < firstDayOfMonth; i++) { calendarDays.innerHTML += `<div class="calendar-day empty"></div>`; }
        const selectedIso = mode === 'blackout' ? starter.StartDate : getStartDateISO();
        for (let i = 1; i <= daysInMonth; i++) {
            const dayEl = document.createElement('div');
            dayEl.className = 'calendar-day';
            dayEl.textContent = i;
            const dateStr = toYMD(new Date(year, month, i));
            if (mode === 'blackout' && starter.blackoutDates.includes(dateStr)) { dayEl.classList.add('blackout'); }
            if (selectedIso && selectedIso === dateStr) { dayEl.classList.add('selected'); }
            dayEl.onclick = () => {
                if (mode === 'blackout') {
                    const index = starter.blackoutDates.indexOf(dateStr);
                    if (index > -1) {
                        starter.blackoutDates.splice(index, 1);
                        dayEl.classList.remove('blackout');
                    } else {
                        starter.blackoutDates.push(dateStr);
                        dayEl.classList.add('blackout');
                    }
                    renderStarters();
                } else {
                    setStartDateISO(dateStr);
                    closeCalendarModal();
                    stDateInput.focus();
                }
            };
            calendarDays.appendChild(dayEl);
        }
    }

    function closeCalendarModal() {
        byId('calendar-modal').classList.remove('visible');
        if (calendarContext?.mode === 'startDate') stDateInput.setAttribute('aria-expanded', 'false');
        calendarContext = null;
    }
    function openCalendarModal() {
        byId('calendar-modal').classList.add('visible');
        if (calendarContext?.mode === 'startDate') stDateInput.setAttribute('aria-expanded', 'true');
    }

    // --- STARTER MANAGEMENT ---
    function renderStarters() {
        const tb = document.querySelector('#startersTbl tbody');
        if (starters.length === 0) {
            tb.innerHTML = `<tr><td colspan="6" style="text-align:center; color: var(--text-muted); padding: 2rem;">No starters added yet.</td></tr>`;
            syncChecklists();
            return;
        }
        tb.innerHTML = starters.map((s, i) => {
            if (!s.Avatar) s.Avatar = getRandomAvatar();
            const avatar = getAvatarMarkup(s.Avatar);
            return `<tr><td>${i + 1}</td><td><span class="starter-cell">${avatar}<span>${s.Name}</span></span></td><td>${s.StaffID || 'N/A'}</td><td>${toDMY(parseYMD(s.StartDate))}</td><td>${s.blackoutDates.length} day(s)</td><td style="text-align:right"><button data-i='${i}' class='btn ghost open-calendar' type="button">Calendar</button><button data-i='${i}' class='btn ghost remove-starter' type="button">Remove</button></td></tr>`;
        }).join('');
        tb.querySelectorAll('.remove-starter').forEach(b => b.onclick = async () => { const confirmed = await showModal('Confirm Removal', `Are you sure you want to remove ${starters[+b.dataset.i].Name}?`, true); if (confirmed) { starters.splice(+b.dataset.i, 1); renderStarters(); } });
        tb.querySelectorAll('.open-calendar').forEach(b => b.onclick = () => {
            activeStarterIndex = +b.dataset.i;
            calendarContext = { mode: 'blackout' };
            currentCalendarDate = parseYMD(starters[activeStarterIndex].StartDate);
            renderCalendar();
            openCalendarModal();
        });
        syncChecklists();
    }
    function openStartDatePicker(e) {
        if (e) { e.preventDefault(); }
        calendarContext = { mode: 'startDate' };
        const currentIso = getStartDateISO();
        currentCalendarDate = currentIso ? parseYMD(currentIso) : new Date();
        renderCalendar();
        openCalendarModal();
    }
    function addStarter() {
        const Name = byId('stName').value.trim(); const StaffID = byId('stId').value.trim(); const StartDate = getStartDateISO();
        if (!Name || !StartDate) { showModal('Missing Information', 'Both Name and Start Date are required.'); return; }
        starters.push({ Name, StaffID, StartDate, blackoutDates: [], Avatar: getRandomAvatar() });
        renderStarters();
        byId('stName').value = ''; byId('stId').value = ''; setStartDateISO('');
    }
    async function clearStarters() { if (starters.length === 0) { showModal('No Starters', 'There are no starters to clear.'); return; } const confirmed = await showModal('Confirm Clear', 'Are you sure?', true); if (confirmed) { starters = []; renderStarters(); } }
    function importStarters(e) {
        const f = e.target.files[0];
        if (!f) return;
        const fr = new FileReader();
        fr.onload = () => {
            const lines = fr.result.split(/\r?\n/).filter(Boolean);
            lines.shift();
            starters = lines.map(l => { const [Name, StaffID, StartDate] = l.split(','); return { Name, StaffID, StartDate, blackoutDates: [], Avatar: getRandomAvatar() }; });
            renderStarters();
        };
        fr.readAsText(f);
        e.target.value = null;
    }
    function exportStarters() {
        if (starters.length === 0) { showModal('No Starters', 'There are no starters to export.'); return; }
        const header = ['Name', 'StaffID', 'StartDate'];
        const csv = [header.join(',')].concat(starters.map(s => [s.Name, s.StaffID || '', s.StartDate].join(','))).join('\n');
        download('starters.csv', csv);
    }
    function download(name, text) { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([text], { type: 'text/plain' })); a.download = name; a.click(); }

    // --- BUILDER & RENDER LOGIC ---
    async function buildAll() {
        if (allRows.length > 0) {
            const confirmed = await showModal('Roster Exists', 'A schedule already exists. Do you want to replace it?', true);
            if (!confirmed) return;
        }
        if (!starters.length) { showModal('Build Error', 'Add at least one starter.'); return; }

        allRows = [];
        const placedByStarter = new Map();
        const placedByStarterOutlet = new Map();

        function incPlaced(starterName, outlet) { placedByStarter.set(starterName, (placedByStarter.get(starterName) || 0) + 1); if (!placedByStarterOutlet.has(starterName)) placedByStarterOutlet.set(starterName, new Map()); const m = placedByStarterOutlet.get(starterName); m.set(outlet, (m.get(outlet) || 0) + 1); }
        function getPlaced(starterName) { return placedByStarter.get(starterName) || 0; }
        function getPlacedOutlet(starterName, outlet) { return placedByStarterOutlet.get(starterName)?.get(outlet) || 0; }
        function addRow(r) { allRows.push(r); incPlaced(r.Starter, r.Outlet); }

        const used = new Set();
        const welcomeDow = +byId('welcomeDaySel').value;
        const onboardDow = +byId('onboardDaySel').value;
        const elevateDow = +byId('elevateDaySel').value;
        const norm = starters.map(s => { let d = parseYMD(s.StartDate); while (isSun(d)) d.setDate(d.getDate() + 1); return { ...s, NormStart: d }; });
        const groups = {}; for (const s of norm) { const k = toYMD(s.NormStart); (groups[k] ||= []).push(s); }
        for (const dayKey of Object.keys(groups).sort()) {
            let day1 = nextDow(parseYMD(dayKey), welcomeDow);
            let day2 = nextDow(day1, onboardDow, false);
            let day3 = nextDow(day2, elevateDow, false);
            for (const s of groups[dayKey]) {
                addRow(makeRow(s, day1, MANDATORY_SESSIONS[0].start, MANDATORY_SESSIONS[0].label, 1));
                addRow(makeRow(s, day2, MANDATORY_SESSIONS[1].start, MANDATORY_SESSIONS[1].label, 2));
                addRow(makeRow(s, day3, MANDATORY_SESSIONS[2].start, MANDATORY_SESSIONS[2].label, 3));
                s.__state = { currentOutlet: null, remaining: 0, nextDate: addWorkDay(day3) };
            }
        }
        const baseCounts = getBlocks().reduce((m, b) => (m[b.outlet] = b.count, m), {});
        const conflicts = { outletConflicts: 0, dateConflicts: 0, fallbackUsed: 0, safetyTriggered: false };
        let progress = true, safety = 0; const everyone = Object.values(groups).flat();
        while (progress && safety < 5000) {
            progress = false; safety++;
            if (safety > 4000) conflicts.safetyTriggered = true;
            for (const s of everyone) {
                if (getPlaced(s.Name) >= MIN_SHIFTS) { s.__state = null; continue; }
                if (!s.__state) continue;
                let st = s.__state; let cur = nextWorking(st.nextDate); let curKey = toYMD(cur);
                let outlet = st.currentOutlet;
                if (st.remaining <= 0) {
                    let candidates = Object.keys(baseCounts).filter(o => getPlacedOutlet(s.Name, o) < baseCounts[o]);
                    if (!candidates.length) { s.__state = null; continue; }
                    if (shuffle) candidates = shuffled(candidates);
                    const allowedToday = candidates.filter(o => !used.has(curKey + "|" + o) && isOutletAllowedOnDate(o, cur));
                    if (allowedToday.length === 0) conflicts.outletConflicts++;
                    outlet = allowedToday[0] || (shuffle ? shuffled(candidates)[0] : candidates[0]);
                    st.currentOutlet = outlet;
                    st.remaining = Math.max(0, baseCounts[outlet] - getPlacedOutlet(s.Name, outlet));
                }
                const initialDate = cur;
                let dateSafety = 0;
                while (s.blackoutDates.includes(curKey) || used.has(curKey + "|" + outlet) || !isOutletAllowedOnDate(outlet, cur) || !canWorkThisDay(s.Name, cur) || !hasMinRest(s.Name, cur, pickTime(outlet, allRows.length))) { 
                    cur = addWorkDay(cur); 
                    curKey = toYMD(cur); 
                    if (++dateSafety > 100) break; 
                }
                if (cur > initialDate) conflicts.dateConflicts++;
                const t = pickTime(outlet, allRows.length);
                addRow(makeRow(s, cur, t, outlet, getPlaced(s.Name) + 1));
                used.add(curKey + "|" + outlet);
                st.remaining -= 1; st.nextDate = addWorkDay(cur); progress = true;
            }
        }
        for (const s of everyone) {
            let placed = getPlaced(s.Name); if (placed >= MIN_SHIFTS) continue;
            let last = allRows.filter(r => r.Starter === s.Name).map(r => r.Date).sort().pop();
            let cur = last ? addWorkDay(parseYMD(last)) : nextWorking(s.NormStart);
            let rot = 0, guard = 0; const PREF = ["SOV South Floor", "SOV South Bar", "Oasis Food", "Oasis Bar", "SOV North Floor", "SOV Dining"];
            let fallbackNeeded = false;
            while (placed < MIN_SHIFTS && guard < 5000) {
                guard++; const key = toYMD(cur);
                if (s.blackoutDates.includes(key)) { cur = addWorkDay(cur); continue; }
                let outlet = PREF.find(o => !used.has(key + "|" + o) && isOutletAllowedOnDate(o, cur));
                if (!outlet || !canWorkThisDay(s.Name, cur) || !hasMinRest(s.Name, cur, pickTime(outlet, rot))) { 
                    cur = addWorkDay(cur); 
                    fallbackNeeded = true;
                    continue; 
                }
                const t = pickTime(outlet, rot++);
                addRow(makeRow(s, cur, t, outlet, getPlaced(s.Name) + 1));
                used.add(key + "|" + outlet); placed++; cur = addWorkDay(cur);
            }
            if (fallbackNeeded) conflicts.fallbackUsed++;
        }
        allRows.sort((a, b) => a.Starter.localeCompare(b.Starter) || a.Date.localeCompare(b.Date) || a.Start.localeCompare(b.Start));
        
        // Generate meaningful conflict status message
        const totalConflicts = conflicts.outletConflicts + conflicts.dateConflicts + conflicts.fallbackUsed;
        let statusMessage = `Built ${allRows.length} shifts for ${starters.length} starter(s)`;
        
        if (totalConflicts > 0) {
            const conflictParts = [];
            if (conflicts.outletConflicts > 0) conflictParts.push(`${conflicts.outletConflicts} outlet conflicts`);
            if (conflicts.dateConflicts > 0) conflictParts.push(`${conflicts.dateConflicts} scheduling conflicts`);
            if (conflicts.fallbackUsed > 0) conflictParts.push(`${conflicts.fallbackUsed} fallback shifts`);
            if (conflicts.safetyTriggered) conflictParts.push('complex scheduling');
            statusMessage += ` • Resolved: ${conflictParts.join(', ')}`;
        }
        
        byId('conflicts').textContent = statusMessage;
        renderSched(allRows);
    }
    async function clearRoster() {
        if (allRows.length === 0) {
            showModal('Roster Empty', 'There is no schedule to clear.');
            return;
        }
        const confirmed = await showModal('Clear Roster', 'Are you sure you want to clear the entire generated schedule?', true);
        if (confirmed) {
            allRows = [];
            renderSched([]);
            byId('conflicts').textContent = '—';
        }
    }
    function renderSched(rows) {
        const tb = document.querySelector('#schedTbl tbody'); tb.innerHTML = '';
        if (rows.length === 0) { tb.innerHTML = `<tr><td colspan="8" style="text-align:center; color: var(--text-muted); padding: 2rem;">No schedule generated yet.</td></tr>`; return; }
        let curStarter = null;
        for (const r of rows) {
            const avatarMarkup = getAvatarMarkup(r.Avatar);
            if (r.Starter !== curStarter) {
                curStarter = r.Starter;
                const trHead = document.createElement('tr'); trHead.className = 'group-row';
                trHead.innerHTML = `<td colspan="8"><div class="group-row-header">${avatarMarkup}<div><b>${r.Starter}</b><div class="group-row-subtext">Staff ID: ${r.StaffID || 'N/A'}</div></div></div></td>`;
                tb.appendChild(trHead);
            }
            const tr = document.createElement('tr');
            tr.innerHTML = `<td><span class="starter-cell">${avatarMarkup}<span>${r.Starter}</span></span></td><td>${r.StaffID || 'N/A'}</td><td>${toDMY(parseYMD(r.Date))}</td><td>${r.Start}</td><td>${r.End}</td><td>${r.Outlet}</td><td>${r.Step}</td><td>${r.Shift}</td>`;
            tb.appendChild(tr);
        }
    }
    function getBlocks() { return [{ outlet: "Oasis Food", count: Math.max(0, +byId('blk_food').value || 0) }, { outlet: "Oasis Bar", count: Math.max(0, +byId('blk_obar').value || 0) }, { outlet: "SOV South Floor", count: Math.max(3, +byId('blk_floor').value || 0) }, { outlet: "SOV North Floor", count: Math.max(0, +byId('blk_nfloor').value || 0) }, { outlet: "SOV South Bar", count: Math.max(0, +byId('blk_bar').value || 0) }, { outlet: "SOV Dining", count: Math.max(0, +byId('blk_dining').value || 0) }]; }
    function makeRow(starter, dateObj, start, outlet, step) { const [hh, mm] = start.split(":").map(Number); const endH = (hh + 5) % 24, endM = mm; return { Starter: starter.Name, StaffID: starter.StaffID || '', Avatar: starter.Avatar || '', Date: toYMD(dateObj), Start: start, End: pad2(endH) + ":" + pad2(endM), Outlet: outlet, Step: step, Shift: start.replace(":", "") + "-" + pad2(endH) + pad2(endM) + " " + outlet + " TRN" }; }
    function pickTime(outlet, i) {
        const times = (RULES[outlet] || ["09:00"]).filter(t => t <= "20:00");
        const safeTimes = times.length ? times : ["20:00"];
        return safeTimes[i % safeTimes.length];
    }

    // --- ATTACH EVENT LISTENERS ---
    byId('modal-cancel').onclick = () => { byId('modal').classList.remove('visible'); if (modalResolve) modalResolve(false); };
    byId('modal-confirm').onclick = () => { byId('modal').classList.remove('visible'); if (modalResolve) modalResolve(true); };
    byId('modal').onclick = (e) => { if (e.target === byId('modal')) { byId('modal').classList.remove('visible'); if (modalResolve) modalResolve(false); } };
    byId('prev-month').onclick = () => { currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1); renderCalendar(); };
    byId('next-month').onclick = () => { currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1); renderCalendar(); };
    byId('calendar-close').onclick = closeCalendarModal;
    byId('calendar-modal').onclick = (e) => { if (e.target === byId('calendar-modal')) closeCalendarModal(); };
    setStartDateISO(getStartDateISO());
    stDateInput.addEventListener('click', openStartDatePicker);
    stDateInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') openStartDatePicker(e); });
    byId('addStarter').onclick = addStarter;
    byId('clearStarters').onclick = clearStarters;
    byId('importStartersBtn').onclick = () => byId('importStarters').click();
    byId('importStarters').onchange = importStarters;
    byId('exportStartersBtn').onclick = exportStarters;
    byId('loadDefaultCompetencies').onclick = loadDefaultCompetencies;
    byId('importTemplateBtn').onclick = () => byId('importTemplateInput').click();
    byId('importDatasetBtn').onclick = () => byId('importDatasetInput').click();
    byId('importTemplateInput').onchange = handleTemplateImport;
    byId('importDatasetInput').onchange = handleDatasetImport;
    byId('checklistPreviewSelect').addEventListener('change', handleChecklistSelectionChange);
    byId('exportChecklistCsv').onclick = exportAllChecklistsCsv;
    byId('exportChecklistXls').onclick = exportAllChecklistsXls;
    byId('exportSelectedChecklistCsv').onclick = exportSelectedChecklistCsv;
    byId('printChecklistBtn').onclick = printChecklists;
    byId('shuffleBlocks').onclick = () => {
        shuffle = !shuffle;
        const btn = byId('shuffleBlocks');
        btn.textContent = 'Shuffle: ' + (shuffle ? 'ON' : 'OFF');
        btn.style.borderColor = shuffle ? 'var(--brand-secondary)' : 'var(--border-secondary)';
    };
    byId('buildAll').onclick = buildAll;
    byId('clearRosterBtn').onclick = clearRoster;
    byId('exportAllCsv').onclick = () => { if (!allRows.length) { showModal('Export Error', 'Build a schedule first.'); return; } const header = ['Starter', 'StaffID', 'Date', 'Start', 'End', 'Outlet', 'Step', 'Shift']; const csv = [header.join(',')].concat(allRows.map(r => [r.Starter, r.StaffID || '', toDMY(parseYMD(r.Date)), r.Start, r.End, r.Outlet, r.Step, r.Shift].join(','))).join('\n'); download('schedules.csv', csv); };
    byId('exportAllXls').onclick = async () => {
        if (!allRows.length) { showModal('Export Error', 'Build a schedule first.'); return; }
        if (typeof XLSX === 'undefined') {
            showModal('Export Error', 'Excel export functionality is not available. The required library could not be loaded.');
            return;
        }
        let staticTemplate;
        try {
            staticTemplate = await ensureStaticPgrChecklist();
        } catch (error) {
            console.error('Failed to load PGR competency checklist:', error);
            showModal('Export Error', 'Unable to load the competency checklist data. Please refresh and try again.');
            return;
        }
        const scheduleHeaders = ['Starter', 'Staff ID', 'Date', 'Start Time', 'End Time', 'Outlet', 'Step', 'Shift Code'];
        const scheduleRows = allRows.map(r => ({
            'Starter': r.Starter,
            'Staff ID': r.StaffID || '',
            'Date': toDMY(parseYMD(r.Date)),
            'Start Time': r.Start,
            'End Time': r.End,
            'Outlet': r.Outlet,
            'Step': r.Step,
            'Shift Code': r.Shift
        }));
        const wsSchedule = XLSX.utils.json_to_sheet(scheduleRows, { header: scheduleHeaders });

        const starterHeaders = ['Name', 'Staff ID', 'Start Date'];
        const starterRows = starters.map(s => ({
            'Name': s.Name,
            'Staff ID': s.StaffID || '',
            'Start Date': s.StartDate ? toDMY(parseYMD(s.StartDate)) : ''
        }));
        const wsStarters = XLSX.utils.json_to_sheet(starterRows, { header: starterHeaders });

        const wb = XLSX.utils.book_new();
        const formattingQueue = [];

        const rosterSheetName = 'Roster';
        XLSX.utils.book_append_sheet(wb, wsSchedule, rosterSheetName);
        formattingQueue.push({
            sheetName: rosterSheetName,
            type: 'table',
            options: {
                columnWidths: [28, 16, 16, 12, 12, 24, 12, 28],
                headerRowIndex: 0,
                dataStartRow: 1
            }
        });

        const startersSheetName = 'Starters';
        XLSX.utils.book_append_sheet(wb, wsStarters, startersSheetName);
        formattingQueue.push({
            sheetName: startersSheetName,
            type: 'table',
            options: {
                columnWidths: [28, 16, 16],
                headerRowIndex: 0,
                dataStartRow: 1
            }
        });

        const usedSheetNames = new Set([rosterSheetName, startersSheetName]);
        const overviewRows = [];
        starters.forEach((starter, index) => {
            const {
                sheetRows,
                overviewRows: rows,
                metaStartRow,
                metaEndRow,
                headerRowIndex,
                dataStartRow,
                columnCount,
                columnWidths
            } = buildStaticChecklistSheet(staticTemplate, starter, index);
            if (sheetRows.length > 0) {
                const wsChecklist = XLSX.utils.aoa_to_sheet(sheetRows);
                const sheetName = buildChecklistSheetName(starter, index, usedSheetNames);
                XLSX.utils.book_append_sheet(wb, wsChecklist, sheetName);
                formattingQueue.push({
                    sheetName,
                    type: 'checklist',
                    options: {
                        columnCount,
                        columnWidths,
                        titleRowIndex: 0,
                        metaStartRow,
                        metaEndRow,
                        headerRowIndex,
                        dataStartRow
                    }
                });
            }
            if (rows && rows.length) overviewRows.push(...rows);
        });

        if (overviewRows.length) {
            const overviewHeaders = ['Starter', 'Staff ID', 'Start Date', 'Category', 'Subcategory', 'Item', 'Details'];
            const overviewData = overviewRows.map(row => ({
                'Starter': row.Starter,
                'Staff ID': row.StaffID,
                'Start Date': row.StartDate,
                'Category': row.Category,
                'Subcategory': row.Subcategory,
                'Item': row.Item,
                'Details': row.Details
            }));
            const wsOverview = XLSX.utils.json_to_sheet(overviewData, { header: overviewHeaders });
            const overviewName = makeUniqueSheetName('Competency Overview', usedSheetNames);
            XLSX.utils.book_append_sheet(wb, wsOverview, overviewName);
            formattingQueue.push({
                sheetName: overviewName,
                type: 'table',
                options: {
                    columnWidths: [26, 16, 16, 26, 22, 40, 36],
                    headerRowIndex: 0,
                    dataStartRow: 1
                }
            });
        }

        for (const cfg of formattingQueue) {
            const ws = wb.Sheets[cfg.sheetName];
            if (!ws) continue;
            if (cfg.type === 'table') {
                styleTabularWorksheet(ws, cfg.options);
            } else if (cfg.type === 'checklist') {
                styleChecklistWorksheet(ws, cfg.options);
            }
        }

        XLSX.writeFile(wb, 'roster_and_starters.xlsx');
    };

    // --- INITIAL SETUP ---
    updateChecklistSummaries();
    loadDefaultCompetencies();
    renderStarters();
    renderSched([]);
};

/* --- PWA: register service worker --- */
if("serviceWorker" in navigator && window.location.protocol === 'https:') {
  navigator.serviceWorker.register('sw.js').catch(error => {
    console.warn('Service Worker registration failed:', error);
  });
}
</script>
</html>
